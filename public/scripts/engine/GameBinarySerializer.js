//TODO try to increase the precision of the coder and model(s)

GameEngineLib.GameSerializers = GameEngineLib.GameSerializers || {};

GameEngineLib.GameSerializers.createGameBinarySerializer = function(instance, private)
{
	instance = instance || {};
	private = private || {};
	
	//TODO add debug info
	
	/*
	Flags =
	{
		NET,
		CLONE
		//BINARY?, UI_GEN, NO_REFS??
	}
	*/
	instance.initWrite = function(inFlags)
	{
		private.isWriting = true;
		private.init(inFlags);
	}
	
	instance.initRead = function(inFlags, inData)
	{
		private.isWriting = false;
		private.init(inFlags);
		private.compressor.setString(inData);
	}
	
	instance.getString = function()
	{
		return private.compressor.getString();
	}
	
	private.init = function(inFlags)
	{
		private.net = inFlags.NET;
		//TODO should this really be created every time?? !!likely not!!! It is being created all the time!!
		private.compressor = GameEngineLib.createGameArithmeticCompression();
		private.integerRangeModel = GameEngineLib.
			GameArithmeticCompressionModels.
			createEvenProbabilityIntegerRangeModel();
	}
	
	
	/*
	dataDesc = [
		{
			name : //variable name
			scope : //public / private
			net : true/false,
			min : //int or float
			max : //int or float
			precision : //float only
			//values : []//possible values (strings?/enums)?
			type :
					//X - int
					//X - float
					//X - bool
					//X - string
					//O - filename
					//O - classRef
					//O - position
					//O - array? map/object?
					//O - color?
					//O - image?
					//O - vector?
			//classRefType : //class type for references?
			//file extention(s)?
			//tooltip : //string for the UI
			//noeditor : //not shown in editor
			//var id generated by the order in the list?
		},
	]
	*/
	instance.serializeObject = function(inObject, inDataFormat)
	{
		for(var i = 0; i < inDataFormat.length; ++i)
		{
			var entry = inDataFormat[i];
			
			if(private.net && !entry.net)
			{
				continue;
			}
			
			var scope = inObject[entry.scope];
			switch(entry.type)
			{
				case "bool":
				{
					private.integerRangeModel.setMinMax(0, 1);
					if(private.isWriting)
						private.compressor.encode(scope[entry.name] ? 1 : 0, private.integerRangeModel);
					else
						scope[entry.name] = private.compressor.decode(private.integerRangeModel) === 1 ? true : false;
				}break;
				case "int":
				{
					private.integerRangeModel.setMinMax(entry.min, entry.max);
					if(private.isWriting)
						private.compressor.encode(scope[entry.name], private.integerRangeModel);
					else
						scope[entry.name] = private.compressor.decode(private.integerRangeModel);
				}break;
				case "float":
				{
					var precision = Math.pow(10, entry.precision);
					
					//TODO consider if I should modify the originals like this, and if so, what notification should be given
					//scope[entry.name] = Math.min(scope[entry.name], entry.max);
					//scope[entry.name] = Math.max(scope[entry.name], entry.min);
					
					var wholePart = Math.floor(scope[entry.name]);
					//note the precision is distributed manually because it causes floating point errors if I don't
					var fractionalPart = Math.floor(precision * scope[entry.name] - precision * wholePart);
					
					//TODO consider if I should modify the originals like this, and if so, what notification should be given
					//scope[entry.name] = wholePart + fractionalPart / precision;
					
					if(private.isWriting)
					{
						private.compressor.encode(
							wholePart,
							private.integerRangeModel.setMinMax(
								Math.floor(entry.min),
								Math.ceil(entry.max)
							)
						);
						private.compressor.encode(
							fractionalPart,
							private.integerRangeModel.setMinMax(
								0,
								precision
							)
						);
					}
					else
					{
						scope[entry.name] =
							private.compressor.decode(
								private.integerRangeModel.setMinMax(
									Math.floor(entry.min),
									Math.ceil(entry.max)
								)
							) +
							private.compressor.decode(
								private.integerRangeModel.setMinMax(
									0,
									precision
								)
							) / precision;
					}
				}break;
				case "string":
				{
					//TODO: get a proper dynamic probability model for the strings
					private.integerRangeModel.setMinMax(0, 65535);
					if(private.isWriting)
					{
						var stringLength = scope[entry.name].length;
						var string = scope[entry.name];
						private.compressor.encode(stringLength, private.integerRangeModel);
						for(var charIndex = 0; charIndex < stringLength; ++charIndex)
						{
							private.compressor.encode(string.charCodeAt(charIndex), private.integerRangeModel);
						}
					}
					else
					{
						var stringLength = private.compressor.decode(private.integerRangeModel);
						var string = "";
						for(var charIndex = 0; charIndex < stringLength; ++charIndex)
						{
							string += String.fromCharCode(
								private.compressor.decode(
									private.integerRangeModel
								)
							);
						}
						scope[entry.name] = string;
					}
				}break;
				case "position":
				{
					//HACK!!! TODO these should be float values!!
					scope[entry.name].myX = Math.floor(scope[entry.name].myX);
					scope[entry.name].myY = Math.floor(scope[entry.name].myY);
					//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					
					if(private.isWriting)
					{
						private.compressor.encode(
							scope[entry.name].myX,
							private.integerRangeModel.setMinMax(entry.min.myX, entry.max.myX)
						);
						private.compressor.encode(
							scope[entry.name].myY,
							private.integerRangeModel.setMinMax(entry.min.myY, entry.max.myY)
						);
					}
					else
					{
						scope[entry.name].myX =
							private.compressor.decode(
								private.integerRangeModel.setMinMax(entry.min.myX, entry.max.myX)
							);
						scope[entry.name].myY =
							private.compressor.decode(
								private.integerRangeModel.setMinMax(entry.min.myY, entry.max.myY)
							);
					}
				}break;
			}
		}
	}
	
	instance.isReading = function()
	{
		return !private.isWriting;
	}
	
	return instance;
};


/*
//could also be added automatically or => just to GameObject:
clone = function()
{
	var instance = myClass.create();
	var serializer = GameEngineLib.createSerializer();
	
	serializer.toWriting();
	this.serialize(serializer)
	
	serializer.toReading();
	instance.serialize(serializer)
	
	return instance;
}

//added automatically? => createXXX(instance, private, outReflectionStructure)
serialize = function(inSer)
{
	dataDesc = [
		{
			name : varname
			//var id generated by the order in the list
			scope : //instance / private
			min : x, //int or float
			max : y, //int or float
			precision : z, //float only
			values : []//possible values
			type : //int, float, color, classRef, filename, image, vector, string, bool
				//position, array? map/object?
			classRefType : //class type
			net : true/false,
			//get/set?
		},
	]
	
	inSer.serialize({this, private, dataDesc})
}

objectToNamePath = function(object)
objectToIDPath = function(object)
objectFromNamePath = function(name)
objectFromIDPath = function(id)

//classid/instanceid/dataid





serialize(object)
{
	set op function based on read/write/ui gen
	for(i in object.structure)
	{
		var entry = object.structure[i];
		var value = object[entry.scope][entry.name]
		switch(entry.type)
		{
			case int:
			case float:
				min/max + maybe precision
				//read / write / compress / gen UI
				break;
			case string:
				possible values?
				break;
			case classRef:
				break;
			
			//etc
		}
	}
}


//????
RMIs =
[
	{
		functionName : name
		//id is index in list
		params : dataDesc
	}
]

object.Rmi(name, params)
{
	func = RMIs.find(name);
	
}


broadcast group
	added
		serialize all / most
	continued
		deltas


for all netdirtygroup
	serialize(item)
	
for all recv netdata
	get class id
	get item id
	is class.instance owned by sender
		item.serializeIn()
	else
		disconnect them
		trash the rest of their data




Exclusive event listeners so no 2 providers

Arithmetic link Code comment

https://github.com/mozilla/BrowserQuest
*/