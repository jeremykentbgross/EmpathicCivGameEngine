game -> engine_test_game

Network:
-Refactor
-websockets
//http://www.html5rocks.com/en/tutorials/websockets/basics/
-GameObjects
--Listeners
--object destroy
-GameObjectRefs

Physics:
-Triggers
-Rays
--Rays draw in physics
--Add ray keyboard to welcome.html

TECH DEMO PUBLIC DEPLOY!

Start Actual Game!!!




NETWORK:
Class : eventsystem
	create(params)
	{
		newObject = new Constructor
		onCreate()//notify listeners
	}
Object : eventsystem
	destroy()
	{
		onDestroy()//notify listeners
		cleanup()//chainup
	}
	netDirty
	{
		onDirty()//notify netgroup listeners
	}
Network
	-Netgroup
	-createNetGroup
	-<add/remove><User/Object>FromNetGroup<s>()
	-users{}/[]?
NetGroup	//1 netgroup per user, 0-many netgroups per object
	-users
		-socket	//need to keep alive, AND reconnect
	-objects{}
	-dirtylist[]
	-newlist[]
	-destroylist[]
	//-removelist[]???
	addObject(object)//all user objects should be added as objects
	{
		netcreate(object)
		object.listen(this)
	}
	removeObject()
	{
		object.unlisten(this)
		netDestroy()
	}
	addUser(inUser)
	{
		serialize all current objects to user
	}
	removeUser(inUser){???}

User : Object
	-name
	-id
	-ping
	-connected
	-socket (server only)
	-fb/pic/etc?
	-serialize if locally owned?, make local User
	-netgroup (there can only be one)

MessageHeader: (additions)
	id
	msg		//ser string as bytes?
	data
	obj
	//TODO ping/clock/pulse
///////////////////////////////////////////
(current)
User
	-name
	-id

Network : eventsystem
//MESSAGES
	id
	msg		//ser string as bytes?
	data
	obj
	//TODO ping/clock/pulse
//EVENTS
	Events.IdentifiedUser			//GameRules spawn
	Events.ClientDisconnected		//GameRules unspawn
	Events.ConnectedToServer		//chat
	Events.DisconnectedFromServer	//chat
	Events.Msg						//chat
	Events.Data						//Not used!
	Events.NetObjects				//Not used!
//SERVER
	-listenSocket
		-connection => _onClientConnected
	_onClientConnected()
		//connect functions to new socket
		-id => _onIdRecv
		-msg => _onMsgRecv
		-data => _onDataRecv
		-obj => _onObjectsRecv
		-disconnect => _onClientDisconnected
		//tell everyone new connection
		//serialize all to new connection
	_onClientDisconnected()
		//tell all about the disconect
		//emit disconnect event
//CLIENT
	-_socket
		-connect => _onConnectedToServer
		-disconnect => _onDisconnectedFromServer
		-id => _onIdRecv
		-msg => _onMsgRecv
		-data => _onDataRecv
		-obj => _onObjectsRecv
	_onConnectedToServer()
		//assign socket server user
		//send local userid
		//connected event
	_onDisconnectedFromServer()
		//disconnected event
//SHARED
	-maxItemsPerMessage
	-objectHeaderFormat
	-messageHeaderFormat
	-objectHeader
	-messageHeader
	-newInstances
	-dirtyInstances
	-serializer
	_onIdRecv()
		//if server
		//	security checks
		//	if new user send them new id
		//	else reuse old one (todo security)
		//	event user id'ed
		//else overwrite user id with one from server
	_onMsgRecv()
		//event message
		//if server pass it on
	_onDataRecv()***
		//read objects as net objects
		//event data
		//if server and no errors, pass it on
	_onObjectsRecv()***
		//read objects as NOT net objects
		//event objects
		//if server and no errors, pass it on
	sendMessage()//note this is just text
		//if server send to all
		//else send to socket and tell listener it was sent
	_sendData()**//maybe message header defines these
		//if server send data to all or specific socket
		//else send
	_sendObj()**
		//if server send data to all or specific socket
		//else send
	_serializeObjectsIn()
		//read in objects, create when needed
	addNetDirtyObject()
	addNewObject()
	update()
		//for all new instances, send
		//for all dirty instances, send
	_serializeObjectsOut()
		//send it with headers and all
///////////////////////////////////////////














///////////////////////////////////////////
(TARGET)

User : Object
	-name
	-id
	-ping
	-connected
	-socket (server only??)
	-fb/pic/etc?
	-serialize if locally owned?, make local User
	-netgroup (there can only be one)

NetGroup	//1 netgroup per user, 0-many netgroups per object
	-users
		-socket	//need to keep alive, AND reconnect
	-objects{}
	-dirtylist[]
	-newlist[]
	-destroylist[]
	//-removelist[]???
	addObject(object)//all user objects should be added as objects
	{
		netcreate(object)
		object.listen(this)
	}
	removeObject()
	{
		object.unlisten(this)
		netDestroy()
	}
	addUser(inUser)
	{
		serialize all current objects to user
	}
	removeUser(inUser){???}


User
	-name
	-id

Network : eventsystem
//MESSAGES
	id
	msg		//ser string as bytes?
	data
	obj
	//TODO ping/clock/pulse
//EVENTS
	Events.IdentifiedUser			//GameRules spawn
	Events.ClientDisconnected		//GameRules unspawn
	Events.ConnectedToServer		//chat
	Events.DisconnectedFromServer	//chat
	Events.Msg						//chat
	Events.Data						//Not used!
	Events.NetObjects				//Not used!
//SHARED
	-users	!!!!!!!!!
		-socket
	-netgroups	!!!!!!!
		-users	!!!!!!!
		-newInstances
		-dirtyInstances
		addNetDirtyObject()
		addNewObject()
		update()
			//for all new instances, send
			//for all dirty instances, send
			
	-maxItemsPerMessage
	-objectHeaderFormat
	-messageHeaderFormat
	-objectHeader
	-messageHeader
	
	-serializer
	_onIdRecv()
		//if server
		//	security checks
		//	if new user send them new id
		//	else reuse old one (todo security)
		//	event user id'ed
		//else overwrite user id with one from server
	_onMsgRecv()
		//event message
		//if server pass it on
	_onDataRecv()***
		//read objects as net objects
		//event data
		//if server and no errors, pass it on
	_onObjectsRecv()***
		//read objects as NOT net objects
		//event objects
		//if server and no errors, pass it on
	sendMessage()//note this is just text
		//if server send to all
		//else send to socket and tell listener it was sent
	_sendData()**//maybe message header defines these
		//if server send data to all or specific socket
		//else send
	_sendObj()**
		//if server send data to all or specific socket
		//else send
	_serializeObjectsIn()
		//read in objects, create when needed
	
	_serializeObjectsOut()
		//send it with headers and all
		
//SERVER
	-listenSocket
		-connection => _onClientConnected
	_onClientConnected()
		//connect functions to new socket
		-id => _onIdRecv
		-msg => _onMsgRecv
		-data => _onDataRecv
		-obj => _onObjectsRecv
		-disconnect => _onClientDisconnected
		//tell everyone new connection
		//serialize all to new connection
	_onClientDisconnected()
		//tell all about the disconect
		//emit disconnect event
//CLIENT
	-_socket
		-connect => _onConnectedToServer
		-disconnect => _onDisconnectedFromServer
		-id => _onIdRecv
		-msg => _onMsgRecv
		-data => _onDataRecv
		-obj => _onObjectsRecv
	_onConnectedToServer()
		//assign socket server user
		//send local userid
		//connected event
	_onDisconnectedFromServer()
		//disconnected event

///////////////////////////////////////////








Map:
	binaryarray
	//get rid of current tree?
	-solidspace tree 4 physics
	renderHudMap()
MapHelper
	brezenham?
	proceduralGen