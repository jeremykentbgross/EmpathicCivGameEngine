
Replication:
GObj:
-copyfrom()//chain
-clone(){ret create().copyfrom(this)}
-setdirty(){listadd,noflag?}
-netgroups
Class ser schema //static
//schema var condition
Class (reg?):
-instances{}
-netDirty{}
-new{}
NetUd:
-Forall netgroups?
-Forall classes
--forall new
---ser complete
--forall dirty
---ser dirty
-clear dirty/new
NetNewCon:
-forall classes
--forall inst
---ser complete

/*
//could also be added automatically or => just to GameObject:
clone = function()
{
	var instance = myClass.create();
	var serializer = GameEngineLib.createSerializer();
	
	serializer.toWriting();
	this.serialize(serializer)
	
	serializer.toReading();
	instance.serialize(serializer)
	
	return instance;
}

//added automatically? => createXXX(instance, private, outReflectionStructure)
serialize = function(inSer)
{
	dataDesc = [
		{
			name : varname
			//var id generated by the order in the list
			scope : //instance / private
			min : x, //int or float
			max : y, //int or float
			precision : z, //float only
			values : []//possible values
			type : //int, float, color, classRef, filename, image, vector, string, bool
				//position, array? map/object?
			classRefType : //class type
			net : true/false,
			//get/set?
		},
	]
	
	inSer.serialize({this, private, dataDesc})
}

objectToNamePath = function(object)
objectToIDPath = function(object)
objectFromNamePath = function(name)
objectFromIDPath = function(id)

//classid/instanceid/dataid





serialize(object)
{
	set op function based on read/write/ui gen
	for(i in object.structure)
	{
		var entry = object.structure[i];
		var value = object[entry.scope][entry.name]
		switch(entry.type)
		{
			case int:
			case float:
				min/max + maybe precision
				//read / write / compress / gen UI
				break;
			case string:
				possible values?
				break;
			case classRef:
				break;
			
			//etc
		}
	}
}


//????
RMIs =
[
	{
		functionName : name
		//id is index in list
		params : dataDesc
	}
]

object.Rmi(name, params)
{
	func = RMIs.find(name);
	
}


broadcast group
	added
		serialize all / most
	continued
		deltas


for all netdirtygroup
	serialize(item)
	
for all recv netdata
	get class id
	get item id
	is class.instance owned by sender
		item.serializeIn()
	else
		disconnect them
		trash the rest of their data




Exclusive event listeners so no 2 providers

Arithmetic link Code comment

https://github.com/mozilla/BrowserQuest
*/